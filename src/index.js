import CothorityProtobuf from './cothority-protobuf'

class CothorityMessages extends CothorityProtobuf {
  
  /**
   * Create an encoded message to make a sign request to a cothority node
   * @param message to sign stored in a Uint8Array
   * @param servers list of ServerIdentity
   * @returns {*|Buffer|Uint8Array}
   */
  createSignatureRequest(message, servers) {
    if (!(message instanceof Uint8Array)) {
      throw new Error("message must be a instance of Uint8Array");
    }
    
    const fields = {
      message,
      roster: {
        list: servers
      }
    };
    
    return this.encodeMessage('SignatureRequest', fields);
  }
  
  /**
   * Return the decoded response
   * @param response
   * @returns {*}
   */
  decodeSignatureResponse(response) {
    response = new Uint8Array(response);

    return this.decodeMessage('SignatureResponse', response);
  }
  
  /**
   * Return the decoded response
   * @param response
   * @returns {*}
   */
  decodeStatusResponse(response) {
    response = new Uint8Array(response);

    return this.decodeMessage('StatusResponse', response);
  }

    /**
     * Create an encoded message to make a PinRequest to a cothority node
     * @param pin previously generated by the conode
     * @param publicKey
     * @returns {*|Buffer|Uint8Array}
     */
  createPinRequest(pin, publicKey) {
    const fields = {
      pin: pin,
      public: publicKey
    };

    return this.encodeMessage('PinRequest', fields);
  }

    /**
     * Create an encoded message to store configuration information of a given PoP party
     * @param name
     * @param date
     * @param location
     * @param id
     * @param servers
     * @param aggregate
     * @returns {*|Buffer|Uint8Array}
     */
  createStoreConfig(name, date, location, id, servers, aggregate) {
    const fields = {
      desc: {
        name: name,
        dateTime: date,
        location: location,
        roster: {
          id: id,
          list: servers,
          aggregate: aggregate
        }
      }
    };

    return this.encodeMessage('StoreConfig', fields);
  }

    /**
     * Return the decoded response
     * @param response
     * @returns {*}
     */
  deccdeStoreConfigReply(response) {
    response = new Uint8Array(response);

    return this.decodeMessage('StoreConfigReply', response);
  }

    /**
     * Create an encoded message to finalize on the given descid-popconfig
     * @param descId
     * @param attendees
     * @returns {*|Buffer|Uint8Array}
     */
  createFinalizeRequest(descId, attendees) {
    const fields = {
      descId: descId,
      attendees: attendees
    };

    return this.encodeMessage('FinalizeRequest', fields);
  }

    /**
     * Return the decoded response
     * @param response
     * @returns {*}
     */
  decodeFinalizeResponse(response) {
      response = new Uint8Array(response);

      return this.decodeMessage('FinalizeResponse', response);
  }

  createStoreSkipBlockRequest(id, servers) {
    if (!(id instanceof Uint8Array)) {
      throw new Error("message must be a instance of Uint8Array");
    }

    return this.encodeMessage('StoreSkipBlockRequest', {
      LatestID: id,
      NewBlock: {
        MaximumHeight: 1,
        BaseHeight: 1,
        Data: new Uint8Array([]),
        Roster: {
          list: servers
        }
      }
    });
  }

  decodeStoreSkipBlockResponse(response) {
    response = new Uint8Array(response);

    return this.decodeMessage('StoreSkipBlockResponse', response);
  }

  createLatestBlockRequest(id) {
    if (!(id instanceof Uint8Array)) {
      throw new Error("message must be a instance of Uint8Array");
    }

    return this.encodeMessage('LatestBlockRequest', {
      LatestID: id
    });
  }

  decodeLatestBlockResponse(response) {
    response = new Uint8Array(response);

    return this.decodeMessage('LatestBlockResponse', response);
  }

  createConfigUpdate(id) {
      const fields = {
          id: id
      };

      return this.encodeMessage('ConfigUpdate', fields);
  }


  decodeConfigUpdateReply(response) {
      response = new Uint8Array(response);

      return this.decodeMessage('ConfigUpdateReply', response);
  }

  createDevice(key) {

      const model = this.getModel('Device');

      const fields = {
          point: key
      };

      return model.create(fields);
  }

  createProposeSend(id, config) {
      const fields = {
          id: id,
          config: {
              threshold: config.threshold,
              device: config.device,
              data: config.data
          }
      };

      return this.encodeMessage('ProposeSend', fields);
  }

    createProposeUpdate(id) {
        const fields = {
            id: id
        };

        return this.encodeMessage('ProposeUpdate', fields);
    }


    decodeProposeUpdateReply(response) {
        response = new Uint8Array(response);

        return this.decodeMessage('ProposeUpdateReply', response);
    }

    createProposeVote(id, signer, signature) {
        const fields = {
            id: id,
            signer: signer,
            signature: signature
        };

        return this.encodeMessage('ProposeVote', fields);
    }
}

export default new CothorityMessages();